{"title":"Release 1.0","type":"release","content":"<p>Feb 10, 2025 - Jingsong Lee (<a href=\"mailto:jingsonglee0@gmail.com\" target=\"_blank\" title=\"undefined\" rel=\"noopener\">jingsonglee0@gmail.com</a>)</p>\n<p>Apache Paimon PMC Officially Releases Milestone 1.0 Stable Version (Version 1.0.1).</p>\n<p>This core version has undergone nearly 5 months of meticulous refinement, gathering the wisdom of over 70 developers from the\nglobal open-source community, resulting in more than 520 code submissions that fully demonstrate the power of community-driven\ntechnological evolution. We sincerely thank all the developers who contributed!</p>\n<p>Notably, Paimon 1.0 has successfully passed rigorous production verification from top enterprises such as Alibaba Group and\nByteDance. During the peak of traffic during the Double Eleven Global Shopping Festival, Paimon demonstrated excellent scalability\nand stability. This milestone not only marks the official entry of stream lake-warehouse technology into a new stage of mature \ndevelopment but also proves that Paimon’s lake storage architecture has industrial-grade capabilities to support data storage \nexceeding 100 PB.</p>\n<h2 id=\"overview\">Overview</h2><p>In Paimon 1.0, there were no major kernel modifications introduced; the focus has been on stabilizing and optimizing kernel design.\nWe have introduced some eco-friendly features related to the Catalog, strengthened snapshot submissions, enhanced lookup performance,\nand optimized the storage of primary key tables.</p>\n<ol>\n<li>We have introduced many exciting ecosystem integrations; the Catalog ecosystem now supports Format Tables to be compatible with Hive tables.\nIt also supports views and introduces Object Tables to manage unstructured data.</li>\n<li>Iceberg compatibility has officially entered production availability in version 1.0, with integration into AWS-related ecosystems, and DuckDB&#39;s capability to read Iceberg tables.</li>\n<li>We have significantly optimized the capabilities related to snapshot transactions to handle submissions of extremely large or wide tables.</li>\n<li>We have core enhancements to the Orphan File Clean to enable distributed execution, which is a core part of our daily table management and operations.</li>\n<li>The algorithm for local lookups (which is the basis for Lookup Changelog-producer, primary key table Deletion Vectors mode, and Flink Lookup Join) has changed from Hash to Sort, greatly enhancing local disk compression rates.</li>\n<li>Count(*) SQL acceleration has been implemented, which no longer requires reading data files but returns results directly; this acceleration effect will benefit both non-primary key tables and primary key DV tables.</li>\n<li>The Thin mode for primary key tables has been introduced, where primary key-related fields will no longer be stored redundantly; however, this feature is not enabled by default for compatibility reasons.</li>\n<li>The Bitmap in file indexing has been significantly enhanced by allowing the index to be pushed down to the page level of Parquet files, which significantly boosts query performance.</li>\n</ol>\n<h2 id=\"ecosystem\">Ecosystem</h2><h3 id=\"catalog-ecosystem\">Catalog Ecosystem</h3><img src=\"./img/v1-catalog.png\" alt=\"catalog\" />\n\n<p>The image above shows the current Catalog ecosystem related to Paimon 1.0. Before version 1.0, there were only Paimon Primary Key Tables and Append Tables; version 1.0 has greatly expanded this ecosystem:</p>\n<ol>\n<li>View: When the metastore (such as Hive) supports views, it can support views. If there is no metastore, only temporary views can be used, which exist only in the current session. Persistent views will currently save the original SQL. If cross-engine view usage is needed, users can write cross-engine SQL statements.</li>\n<li>Format Table: When the metastore (such as Hive) supports format tables, Format Tables are supported. Hive tables in the metastore will map to Paimon&#39;s format tables for reading and writing by computation engines (Spark, Hive, Flink). This type is mainly used for compatibility with Hive tables.</li>\n<li>Object Table: Object Tables provide metadata indexing for unstructured data objects in designated object storage directories, allowing users to analyze unstructured data in object storage.</li>\n<li>Materialized Table: Materialized Tables aim to simplify batch processing and streaming data pipelines, providing a consistent development experience, such as with Flink Materialized Tables. Currently, only Flink SQL is integrated into materialized tables.</li>\n</ol>\n<p>The upcoming Paimon versions will:</p>\n<ol>\n<li>Bring support for Views and Format Tables to FileSystemCatalog.</li>\n<li>Consider supporting dialects for Views.</li>\n<li>Propose cross-engine materialized view definitions for Materialized Tables, allowing cooperative operations with engines such as Spark and StarRocks.</li>\n<li>Introduce cross-engine function definitions.</li>\n</ol>\n<h3 id=\"iceberg-compatibility\">Iceberg Compatibility</h3><p>Paimon supports generating Iceberg-compatible metadata so that Iceberg Readers can directly use Paimon tables. This Iceberg compatibility has become production-ready in this version!</p>\n<img src=\"./img/v1-iceberg.png\" alt=\"iceberg\" />\n\n<p>With Iceberg compatibility, a large ecosystem of Iceberg can be unlocked, including various serverless computing products. Paimon 1.0 core addressed:</p>\n<ol>\n<li>Support for complex types.</li>\n<li>Verification of integration with Athena and Glue Catalog.</li>\n<li>Verification of DuckDB’s capability to read Iceberg data.</li>\n</ol>\n<p>Paimon key tables organize data files as an LSM tree, meaning data files must be merged before queries or combined with Deletion Vectors. However, Iceberg Readers cannot merge data files and can only query the highest level of data files in the LSM tree. The highest-level data files are generated through full compaction.</p>\n<p>Fortunately, Iceberg’s latest R&amp;D also supports Deletion Vectors, allowing Paimon primary key table Deletion Vectors to produce Iceberg snapshots without loss. Further integration will occur following Iceberg&#39;s new version release.</p>\n<h2 id=\"transactions\">Transactions</h2><p>In Alibaba Group&#39;s Taobao business, the largest single partition of the biggest table even exceeds 100TB, presenting many challenges for the Manifest. Therefore, in Paimon 1.0, we have significantly improved the performance of snapshot submissions and the performance during multi-job writing.</p>\n<p>This version introduced Manifest Merging memory optimization, avoiding retaining full DataFileMeta in memory, preventing memory issues that had led to instability (e.g., OOM) in previous versions.</p>\n<img src=\"./img/v1-commit.png\" alt=\"commit\" />\n\n<p>Simultaneous submissions from multiple jobs are a core capability of Paimon; for instance, one job writes data while another handles compaction. However, in previous versions, if the data volume was too large and too many files were involved, submission failures occurred frequently, which could lead to job failover. This version significantly optimizes the recurring conflict issues during simultaneous writes, preventing prolonged conflicts that could lead to job failover.</p>\n<p>This version introduced a Dense mode for statistics that avoids occupying a lot of unnecessary space, allowing super wide tables with over 1000 columns to be well supported. The amount of metadata storage has been reduced by 100 times when &#39;metadata.stats-mode&#39; = &#39;none&#39;.</p>\n<p>The Dense mode for statistics may introduce compatibility issues; however, it only affects the &#39;metadata.stats-mode&#39; = &#39;none&#39; case. If you want to maintain compatibility with old-version Readers, you can configure &#39;metadata.stats-dense-store&#39; = &#39;false&#39;, though this is generally not recommended as it does not save much metadata space in non-dense mode.</p>\n<p>When deleting files, it also supports not saving statistical information, configurable via &#39;manifest.delete-file-drop-stats&#39; = &#39;true&#39;, with a default value of false due to similar compatibility concerns with older-version Readers. If you have upgraded all Readers, it is advisable to enable this parameter, which will further enhance compaction&#39;s stability.</p>\n<h2 id=\"management\">Management</h2><p>When Paimon’s writing jobs undergo failover, some uncommitted temporary files may remain, wasting storage space in the file system; thus, Paimon provides tools for cleaning orphan files.</p>\n<p>However, this tool was executed in single-machine mode in previous versions, leading to significant performance issues in cleaning super large tables. Therefore, this version has introduced distributed execution capabilities that support Flink and Spark computation engines.</p>\n<h2 id=\"performance\">Performance</h2><h3 id=\"local-lookup\">Local Lookup</h3><p>Local lookup is the fundamental capability of Paimon’s point query LSM structure, serving as the foundational infrastructure for:</p>\n<ol>\n<li>Lookup changelog-producer: generates changelogs from historical files.</li>\n<li>Primary key table deletion vectors mode: generates deletion vectors from historical files.</li>\n<li>Flink Lookup Join: uses local lookup when the join condition is the primary key of the dimension table.</li>\n</ol>\n<p>Earlier versions used HashFile to solve the lookup challenge, though it had two drawbacks:</p>\n<ol>\n<li>Multiple disk copies occur while generating HashFile.</li>\n<li>HashFile had poor compression rates, even with ZSTD compression only achieving 2-3 times compression.</li>\n</ol>\n<p>In Paimon 1.0, we switched to a new Sort Based file format:</p>\n<img src=\"./img/v1-sort.png\" alt=\"sort\" />\n\n<p>This format, similar to LevelDB SST files, has better compression rates and lower disk IO amplification. Tests on various datasets have shown compression rates improved by 3-5 times in many scenarios compared to Hash files.</p>\n<h3 id=\"count-optimization\">Count(*) Optimization</h3><p>Paimon stores statistical information about data files in the Manifest. For Count(*) SQL queries, the data could originally be returned from within the Manifest, but prior versions still read every file, leading to high consumption.</p>\n<p>In Paimon 1.0, we optimized this SQL in conjunction with Flink and Spark, for example, in the following SQL:</p>\n<pre class=\"code\"><code><span class=\"token comment\">-- Querying Append table, can be accelerated</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> APPEND_T<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- Querying Append table with specified partition, can be accelerated</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> APPEND_T <span class=\"token keyword\">WHERE</span> dt <span class=\"token operator\">=</span> <span class=\"token string\">'20250101'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- Querying primary key table in DV mode, can be accelerated</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> PRIMARY_KEY_T_DV<span class=\"token punctuation\">;</span></code></pre><h3 id=\"thin-mode-for-primary-key-tables\">Thin Mode for Primary Key Tables</h3><p>Previously, Paimon saved the following structure to the primary key table data files:</p>\n<ol>\n<li>Key columns</li>\n<li>_VALUE_KIND</li>\n<li>_SEQUENCE_NUMBER</li>\n<li>Value columns</li>\n</ol>\n<p>In practice, it can be observed that the Value columns already contain all Key columns, thus saving the same data redundantly.</p>\n<p>In the new version, the &#39;data-file.thin-mode&#39; option has been provided to avoid saving redundant Key columns, which can save storage and enhance read/write performance.</p>\n<p>Note that this feature may cause compatibility issues with old-version Readers; therefore, it is not enabled by default. Please ensure to upgrade your reading end first.</p>\n<h3 id=\"file-index\">File Index</h3><p>The bitmap index in previous versions had some effect on point queries but was limited. In this version:</p>\n<ol>\n<li>The Bitmap has been pushed down to the Parquet Reader and operates at the page level, significantly enhancing the filtering effect of the Bitmap and improving performance.</li>\n<li>Bit-Slice Index Bitmap has been supported; BSI file indexing is a numeric range index used to accelerate range queries.</li>\n<li>Additionally, primary key tables in Deletion Vectors mode support file-level indexing.</li>\n</ol>\n<p>The new Bitmap index is also under discussion in the community and will significantly enhance performance when indexing columns have a high cardinality.</p>\n<h3 id=\"catalog-optimization\">Catalog Optimization</h3><p>To avoid bottlenecks caused by metadata, the Catalog has also undergone some optimizations:</p>\n<ol>\n<li>HiveCatalog: Significantly optimized unnecessary getTable calls, greatly accelerating the performance of listTables.</li>\n<li>CachingCatalog: Introduced partition caching, added snapshot file caching, and included cached statistics.</li>\n</ol>\n<h3 id=\"parquet-reader\">Parquet Reader</h3><p>We completely restructured Paimon&#39;s Parquet Reader by referencing Spark SQL&#39;s Parquet Reader, significantly improving the read performance of complex types and reducing bugs related to complex types.</p>\n<h2 id=\"other-features\">Other Features</h2><p>Improvements in Nested Schema support Nested Projection Pushdown and Nested Schema Evolution, allowing Paimon to fully support nested types and complete Schema Evolution.</p>\n<p>Interestingly, a binlog system table has been introduced to allow querying binlogs through a binlog table; previous and subsequent updates will be packed into a single line, allowing stream reads to behave like MySQL binlogs, enabling you to process -U and +U messages together.</p>\n<h2 id=\"flink-integration\">Flink Integration</h2><p>In addition to advancing the Materialized Table with the Flink community, Paimon 1.0 also presents many enhancements related to stream processing and batch processing.</p>\n<p>For Stream Processing:</p>\n<ol>\n<li>CDC: Kafka Sync now supports complex types and Aliyun JSON types.</li>\n<li>Local Merge (configured with &#39;local-merge-buffer-size&#39;) now utilizes a Hash algorithm, which is very beneficial for the efficiency of certain aggregated tables.</li>\n<li>The Lookup Join has added a blacklist mechanism to avoid refresh impacts on stability during critical moments.</li>\n<li>Memory optimizations for automatic compaction of Append tables allow extremely large tables to automatically compact small files.</li>\n<li>When enabling Changelog-producer as Lookup, if Flink&#39;s checkpoint interval is short (e.g., 30 seconds), and the number of buckets is large, each snapshot may generate many small change log files. Therefore, a configuration &#39;changelog.precommit-compact&#39; was introduced to compress small change log files into larger ones.</li>\n</ol>\n<p>For Batch Processing:</p>\n<ol>\n<li>Supports speculative execution in Flink batch processing.</li>\n<li>Supports integration of Flink with Paimon, enabling access to statistics.</li>\n<li>Supports generating Paimon statistics using Flink SQL.</li>\n</ol>\n<h2 id=\"spark-integration\">Spark Integration</h2><p>Spark 4 has released preview 2 version, one of its important capabilities being Variant, including Variant Shredding, which can greatly enhance the handling of semi-structured data. The Paimon community will connect to the Variant and Variant Shredding capabilities in subsequent releases.</p>\n<p>Additionally, Spark SQL supports using dynamic parameters to configure tables, for example:</p>\n<pre class=\"code\"><code><span class=\"token comment\">-- set scan.snapshot-id=1 for the table default.T in any catalogs</span>\n<span class=\"token keyword\">SET</span> spark<span class=\"token punctuation\">.</span>paimon<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">default</span><span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">.</span>scan<span class=\"token punctuation\">.</span><span class=\"token keyword\">snapshot</span><span class=\"token operator\">-</span>id<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">default</span><span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">;</span></code></pre><h2 id=\"future-plans-rest\">Future Plans: REST</h2><p>In future plans, we will focus on building the RESTCatalog and promoting the development of REST Servers. We expect to significantly enhance the overall experience, availability, and usability of the lake-warehouse through REST metadata services.</p>\n","toc":[{"depth":2,"text":"Overview","id":"overview"},{"depth":2,"text":"Ecosystem","id":"ecosystem"},{"depth":3,"text":"Catalog Ecosystem","id":"catalog-ecosystem"},{"depth":3,"text":"Iceberg Compatibility","id":"iceberg-compatibility"},{"depth":2,"text":"Transactions","id":"transactions"},{"depth":2,"text":"Management","id":"management"},{"depth":2,"text":"Performance","id":"performance"},{"depth":3,"text":"Local Lookup","id":"local-lookup"},{"depth":3,"text":"Count(*) Optimization","id":"count-optimization"},{"depth":3,"text":"Thin Mode for Primary Key Tables","id":"thin-mode-for-primary-key-tables"},{"depth":3,"text":"File Index","id":"file-index"},{"depth":3,"text":"Catalog Optimization","id":"catalog-optimization"},{"depth":3,"text":"Parquet Reader","id":"parquet-reader"},{"depth":2,"text":"Other Features","id":"other-features"},{"depth":2,"text":"Flink Integration","id":"flink-integration"},{"depth":2,"text":"Spark Integration","id":"spark-integration"},{"depth":2,"text":"Future Plans: REST","id":"future-plans-rest"}],"alias":"release-1.0","version":"1.0.1","weight":92}