<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Table with PK on Apache Paimon</title>
    <link>//paimon.apache.org/docs/0.8/primary-key-table/</link>
    <description>Recent content in Table with PK on Apache Paimon</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="//paimon.apache.org/docs/0.8/primary-key-table/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Overview</title>
      <link>//paimon.apache.org/docs/0.8/primary-key-table/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//paimon.apache.org/docs/0.8/primary-key-table/overview/</guid>
      <description>Overview #  If you define a table with primary key, you can insert, update or delete records in the table.
Primary keys consist of a set of columns that contain unique values for each record. Paimon enforces data ordering by sorting the primary key within each bucket, allowing users to achieve high performance by applying filtering conditions on the primary key. See CREATE TABLE.
Bucket #  Unpartitioned tables, or partitions in partitioned tables, are sub-divided into buckets, to provide extra structure to the data that may be used for more efficient querying.</description>
    </item>
    
    <item>
      <title>Data Distribution</title>
      <link>//paimon.apache.org/docs/0.8/primary-key-table/data-distribution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//paimon.apache.org/docs/0.8/primary-key-table/data-distribution/</guid>
      <description>Data Distribution #  By default, Paimon table only has one bucket, which means it only provides single parallelism read and write. Please configure the bucket strategy to your table.  A bucket is the smallest storage unit for reads and writes, each bucket directory contains an LSM tree.
Fixed Bucket #  Configure a bucket greater than 0, using Fixed Bucket mode, according to Math.abs(key_hashcode % numBuckets) to compute the bucket of record.</description>
    </item>
    
    <item>
      <title>Merge Engine</title>
      <link>//paimon.apache.org/docs/0.8/primary-key-table/merge-engine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//paimon.apache.org/docs/0.8/primary-key-table/merge-engine/</guid>
      <description>Merge Engine #  When Paimon sink receives two or more records with the same primary keys, it will merge them into one record to keep primary keys unique. By specifying the merge-engine table property, users can choose how records are merged together.
Always set table.exec.sink.upsert-materialize to NONE in Flink SQL TableConfig, sink upsert-materialize may result in strange behavior. When the input is out of order, we recommend that you use Sequence Field to correct disorder.</description>
    </item>
    
    <item>
      <title>Changelog Producer</title>
      <link>//paimon.apache.org/docs/0.8/primary-key-table/changelog-producer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//paimon.apache.org/docs/0.8/primary-key-table/changelog-producer/</guid>
      <description>Changelog Producer #  Streaming write can continuously produce the latest changes for streaming read.
By specifying the changelog-producer table property when creating the table, users can choose the pattern of changes produced from table files.
The changelog-producer table property only affects changelog from table files. It does not affect the external log system.  None #  By default, no extra changelog producer will be applied to the writer of table.</description>
    </item>
    
    <item>
      <title>Sequence &amp; Rowkind</title>
      <link>//paimon.apache.org/docs/0.8/primary-key-table/sequence-rowkind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//paimon.apache.org/docs/0.8/primary-key-table/sequence-rowkind/</guid>
      <description>Sequence and Rowkind #  When creating a table, you can specify the &#39;sequence.field&#39; by specifying fields to determine the order of updates, or you can specify the &#39;rowkind.field&#39; to determine the changelog kind of record.
Sequence Field #  By default, the primary key table determines the merge order according to the input order (the last input record will be the last to merge). However, in distributed computing, there will be some cases that lead to data disorder.</description>
    </item>
    
    <item>
      <title>Deletion Vectors</title>
      <link>//paimon.apache.org/docs/0.8/primary-key-table/deletion-vectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//paimon.apache.org/docs/0.8/primary-key-table/deletion-vectors/</guid>
      <description>Deletion Vectors #  Overview #  The Deletion Vectors mode is designed to takes into account both data reading and writing efficiency.
In this mode, additional overhead (looking up LSM Tree and generating the corresponding Deletion File) will be introduced during writing, but during reading, data can be directly retrieved by employing data with deletion vectors, avoiding additional merge costs between different files.
Furthermore, data reading concurrency is no longer limited, and non-primary key columns can also be used for filter push down.</description>
    </item>
    
    <item>
      <title>Read Optimized</title>
      <link>//paimon.apache.org/docs/0.8/primary-key-table/read-optimized/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//paimon.apache.org/docs/0.8/primary-key-table/read-optimized/</guid>
      <description>Read Optimized #  Overview #  For Primary Key Table, it&amp;rsquo;s a &amp;lsquo;MergeOnRead&amp;rsquo; technology. When reading data, multiple layers of LSM data are merged, and the number of parallelism will be limited by the number of buckets. Although Paimon&amp;rsquo;s merge performance is efficient, it still cannot catch up with the ordinary AppendOnly table.
We recommend that you use Deletion Vectors mode.
If you don&amp;rsquo;t want to use Deletion Vectors mode, you want to query fast enough in certain scenarios, but can only find older data, you can also:</description>
    </item>
    
  </channel>
</rss>
